# مفاهیم پایه و اولیه در زبان برنامه‌نویسی Go: متغیرها و موارد مرتبط

**توضیح کلی**: این جزوه به بررسی مفاهیم پایه و اولیه زبان Go با تمرکز بر متغیرها، انواع داده‌ها، ثابت‌ها، و سایر موارد مرتبط می‌پردازد. Go یک زبان برنامه‌نویسی مدرن است که توسط گوگل توسعه یافته و به دلیل سادگی، عملکرد بالا، و پشتیبانی قوی از همزمانی (concurrency) محبوبیت زیادی پیدا کرده است. در این جزوه، هر بخش با توضیحات کامل، مثال‌های عملی، و نکات تخصصی ارائه می‌شود تا یادگیری عمیق و کاربردی باشد.

---

## 1. مقدمه‌ای بر زبان Go

### 1.1. ویژگی‌های کلیدی Go
**توضیح**: Go برای حل مشکلات برنامه‌نویسی در مقیاس بزرگ طراحی شده است. ویژگی‌های کلیدی آن شامل موارد زیر است:
- **سادگی**: سینتکس Go ساده و بدون پیچیدگی‌های غیرضروری است، که یادگیری و خوانایی کد را آسان می‌کند.
- **همزمانی**: Go از مدل همزمانی مبتنی بر goroutine‌ها و کانال‌ها پشتیبانی می‌کند، که توسعه برنامه‌های مقیاس‌پذیر را ساده می‌کند.
- **تایپ استاتیک**: نوع متغیرها در زمان کامپایل مشخص می‌شود، که خطاهای نوع را کاهش می‌دهد.
- **عملکرد بالا**: Go به کد ماشین کامپایل می‌شود و عملکردی نزدیک به C/C++ دارد.
- **ابزارهای داخلی**: ابزارهایی مثل `go fmt` (برای فرمت‌بندی کد)، `go test` (برای تست)، و `go doc` (برای مستندسازی) به توسعه‌دهندگان کمک می‌کنند.

**مثال**:
```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, Go!")
}
```

**توضیح خط‌به‌خط**:
- `package main`: هر فایل Go باید به یک بسته (package) تعلق داشته باشد. `main` بسته‌ای است که نقطه ورود برنامه را مشخص می‌کند.
- `import "fmt"`: پکیج `fmt` برای عملیات ورودی/خروجی (مثل چاپ متن) استفاده می‌شود.
- `func main()`: تابع اصلی که اجرای برنامه از آن شروع می‌شود.
- `fmt.Println("Hello, Go!")`: متنی را در کنسول چاپ می‌کند.

**چرا مهم است؟**: این ساختار ساده نشان‌دهنده فلسفه Go است: حداقل پیچیدگی با حداکثر کارایی.

---

## 2. متغیرها در Go

### 2.1. تعریف متغیر
**توضیح**: متغیرها در Go برای ذخیره داده‌ها استفاده می‌شوند. برخلاف برخی زبان‌ها که متغیرها می‌توانند بدون تعریف استفاده شوند، Go یک زبان تایپ استاتیک است و متغیرها باید قبل از استفاده تعریف شوند. Go چند روش برای تعریف متغیرها ارائه می‌دهد که هر کدام کاربرد خاص خود را دارند.

#### روش‌های تعریف متغیر
1. **با استفاده از کلمه کلیدی `var` و نوع صریح**:
   ```go
   var name string = "Ali"
   var age int = 30
   ```

   **توضیح**:
   - `var`: کلمه کلیدی برای تعریف متغیر.
   - `name`, `age`: نام‌های متغیر که باید معنادار باشند.
   - `string`, `int`: نوع داده متغیر که باید صراحتاً مشخص شود.
   - `= "Ali"`, `= 30`: مقدار اولیه متغیر.
   - این روش برای تعریف متغیرهایی با نوع مشخص و در هر دامنه‌ای (محلی یا بسته) مناسب است.

2. **بدون مقدار اولیه (مقدار پیش‌فرض)**:
   ```go
   var name string // مقدار پیش‌فرض: ""
   var age int     // مقدار پیش‌فرض: 0
   var isActive bool // مقدار پیش‌فرض: false
   ```

   **توضیح**:
   - اگر مقدار اولیه مشخص نشود، Go مقدار پیش‌فرض (zero value) را اختصاص می‌دهد.
   - مقادیر پیش‌فرض:
     - اعداد: `0`
     - رشته‌ها: `""` (رشته خالی)
     - بولین: `false`
     - اشاره‌گرها، اسلایس‌ها، مپ‌ها، کانال‌ها، رابط‌ها: `nil`
   - این روش زمانی مفید است که نمی‌خواهید مقدار اولیه را بلافاصله تنظیم کنید.

3. **استنتاج نوع با استفاده از `:=`**:
   ```go
   name := "Ali" // استنتاج نوع به string
   age := 30     // استنتاج نوع به int
   ```

   **توضیح**:
   - `:=` برای تعریف متغیر با استنتاج نوع استفاده می‌شود.
   - کامپایلر نوع متغیر را از مقدار اولیه تشخیص می‌دهد (مثلاً `"Ali"` به `string`).
   - این روش فقط در داخل توابع قابل استفاده است و کد را مختصرتر می‌کند.
   - **نکته**: نمی‌توان از `:=` برای تعریف متغیر در سطح بسته استفاده کرد.

4. **تعریف چند متغیر به صورت همزمان**:
   ```go
   var (
       name    string = "Ali"
       age     int    = 30
       isAdmin bool   = true
   )
   ```

   یا:
   ```go
   var x, y, z int = 1, 2, 3
   ```

   **توضیح**:
   - بلاک `var` برای تعریف چندین متغیر به صورت خوانا استفاده می‌شود.
   - روش دوم برای متغیرهای هم‌نوع مناسب است.
   - این روش برای متغیرهای مرتبط یا تنظیمات اولیه پروژه مفید است.

### 2.2. قوانین نام‌گذاری متغیرها
**توضیح**: نام‌گذاری متغیرها در Go باید از قوانین و کنوانسیون‌های خاصی پیروی کند تا کد خوانا و استاندارد باشد.

- **قوانین**:
  - نام باید با حرف یا `_` شروع شود.
  - می‌تواند شامل حروف، اعداد، و `_` باشد.
  - حساس به حروف بزرگ و کوچک است:
    ```go
    var Name string = "Ali"
    var name string = "Bob" // متغیر متفاوت
    ```

- **کنوانسیون‌ها**:
  - **نام‌های کوتاه و معنادار**: از نام‌های طولانی و غیرضروری اجتناب کنید.
    ```go
    userCount := 100 // خوب
    numberOfUsersInSystem := 100 // بیش از حد طولانی
    ```
  - **camelCase**: برای متغیرهای غیرصادراتی (private) استفاده کنید.
    ```go
    userName := "Ali"
    isActive := true
    ```
  - **حرف بزرگ برای متغیرهای صادراتی**: متغیرهایی که با حرف بزرگ شروع می‌شوند، در بسته‌های دیگر قابل دسترسی هستند.
    ```go
    var UserID int = 123 // صادراتی
    var userID int = 456 // غیرصادراتی
    ```
  - **اجتناب از `_` در نام‌ها**: مگر در موارد خاص مثل نادیده گرفتن متغیرها.

**چرا مهم است؟**: نام‌گذاری صحیح خوانایی کد را افزایش می‌دهد و از خطاهای توسعه جلوگیری می‌کند.

### 2.3. دامنه (Scope) متغیرها
**توضیح**: دامنه متغیر مشخص می‌کند که متغیر در کجای برنامه قابل دسترسی است. Go دامنه‌های مختلفی را پشتیبانی می‌کند.

- **دامنه محلی**:
  ```go
  func main() {
      x := 10 // دامنه محلی در main
      if true {
          y := 20 // دامنه محلی در بلاک if
          fmt.Println(x, y) // خروجی: 10 20
      }
      // fmt.Println(y) // خطا: y تعریف نشده
  }
  ```

  **توضیح**:
  - متغیر `x` در کل تابع `main` قابل دسترسی است.
  - متغیر `y` فقط در بلاک `if` معتبر است و خارج از آن قابل دسترسی نیست.
  - این رفتار از نشت متغیرها به دامنه‌های غیرضروری جلوگیری می‌کند.

- **دامنه بسته (Package Scope)**:
  ```go
  package main

  var globalVar int = 100 // قابل دسترسی در کل بسته

  func main() {
      fmt.Println(globalVar) // خروجی: 100
  }

  func anotherFunc() {
      fmt.Println(globalVar) // همچنان قابل دسترسی
  }
  ```

  **توضیح**:
  - متغیرهای تعریف‌شده در سطح بسته در تمام فایل‌های همان بسته قابل دسترسی هستند.
  - بهتر است استفاده از متغیرهای global محدود شود تا از پیچیدگی و مشکلات همزمانی جلوگیری شود.

- **دامنه صادراتی**:
  ```go
  package mypkg

  var ExportedVar = "I am exported" // قابل دسترسی در بسته‌های دیگر
  var privateVar = "I am private"   // فقط در بسته mypkg
  ```

  **توضیح**:
  - متغیرهایی که با حرف بزرگ شروع می‌شوند، صادراتی (exported) هستند و در بسته‌های دیگر قابل استفاده‌اند.
  - این ویژگی برای طراحی APIهای عمومی در بسته‌ها مهم است.

**چرا مهم است؟**: درک دامنه متغیرها از دسترسی غیرمجاز یا خطاهای منطقی جلوگیری می‌کند.

### 2.4. خطاهای رایج در تعریف متغیر
**توضیح**: برخی اشتباهات رایج در تعریف متغیرها می‌توانند باعث خطاهای کامپایل یا منطقی شوند.

- **عدم استفاده از متغیر**:
  ```go
  var x int = 10 // خطا اگر x استفاده نشود
  ```

  **توضیح**:
  - Go متغیرهای استفاده‌نشده را در زمان کامپایل تشخیص می‌دهد و خطا می‌دهد.
  - این ویژگی کد را تمیز نگه می‌دارد.
  - **راه‌حل**: متغیرهای غیرضروری را حذف کنید یا از `_` برای نادیده گرفتن استفاده کنید.

- **تعریف مجدد در همان دامنه**:
  ```go
  x := 10
  x := 20 // خطا: تعریف مجدد
  ```

  **توضیح**:
  - نمی‌توان در همان دامنه متغیر را با `:=` بازتعریف کرد.
  - **راه‌حل**: برای تخصیص مجدد از `=` استفاده کنید:
    ```go
    x = 20 // صحیح
    ```

- **استفاده از `:=` در سطح بسته**:
  ```go
  package main
  x := 10 // خطا: := فقط در توابع
  ```

  **توضیح**:
  - `:=` فقط در توابع قابل استفاده است.
  - **راه‌حل**: از `var` استفاده کنید:
    ```go
    var x = 10
    ```

---

## 3. انواع داده‌ها در Go

**توضیح**: Go یک زبان تایپ استاتیک است، یعنی نوع هر متغیر در زمان کامپایل مشخص می‌شود. این ویژگی خطاهای نوع را کاهش می‌دهد. Go انواع داده‌های پایه و مرکب را پشتیبانی می‌کند.

### 3.1. انواع داده‌های پایه
**توضیح**: انواع پایه شامل اعداد، رشته‌ها، و بولین‌ها هستند که برای عملیات اولیه استفاده می‌شوند.

1. **عددی**:
   - **اعداد صحیح (Integers)**:
     ```go
     var i int = 42        // پلتفرم-وابسته (32 یا 64 بیت)
     var i8 int8 = 127     // -128 تا 127
     var i16 int16 = 32767 // -32768 تا 32767
     var i32 int32 = 123   // -2^31 تا 2^31-1
     var i64 int64 = 456   // -2^63 تا 2^63-1
     ```

     **توضیح**:
     - `int` اندازه‌اش به پلتفرم بستگی دارد (32 بیت در سیستم‌های 32 بیتی، 64 بیت در سیستم‌های 64 بیتی).
     - انواع `int8`, `int16`, و غیره برای کنترل دقیق اندازه استفاده می‌شوند.
     - برای مقادیر مثبت از انواع بدون علامت استفاده کنید:
       ```go
       var u uint = 42
       var u8 uint8 = 255
       var u16 uint16 = 65535
       ```

   - **اعداد اعشاری (Floating-Point)**:
     ```go
     var f32 float32 = 3.14
     var f64 float64 = 3.14159265359 // دقت بالاتر
     ```

     **توضیح**:
     - `float32` دقت کمتری دارد و برای کاربردهای ساده مناسب است.
     - `float64` دقت بالاتری دارد و برای محاسبات علمی استفاده می‌شود.
     - **نکته**: محاسبات اعشاری ممکن است خطای گرد کردن داشته باشند:
       ```go
       fmt.Println(0.1 + 0.2) // 0.30000000000000004
       ```

   - **اعداد مختلط (Complex)**:
     ```go
     var c64 complex64 = 1 + 2i
     var c128 complex128 = 3 + 4i
     ```

     **توضیح**:
     - برای محاسبات ریاضی پیشرفته (مثل پردازش سیگنال) استفاده می‌شوند.
     - `complex64` از `float32` و `complex128` از `float64` تشکیل شده است.
     - عملیات:
       ```go
       fmt.Println(real(c64), imag(c64)) // 1 2
       ```

2. **رشته‌ای (String)**:
   ```go
   var s string = "Hello, Go!"
   ```

   **توضیح**:
   - رشته‌ها در Go مجموعه‌ای از بایت‌ها هستند و immutable (غیرقابل تغییر) هستند.
   - دسترسی به کاراکترها:
     ```go
     fmt.Println(s[0]) // 72 (بایت 'H')
     ```
   - برای کار با کاراکترهای یونیکد (مثل emoji) از `rune` استفاده کنید:
     ```go
     runes := []rune(s)
     fmt.Println(runes[0]) // 72
     ```
   - عملیات رشته‌ای:
     ```go
     s2 := s + " World" // الحاق
     fmt.Println(len(s)) // طول
     ```

3. **بولین (Boolean)**:
   ```go
   var b bool = true
   ```

   **توضیح**:
   - فقط دو مقدار: `true` یا `false`.
   - عملگرهای منطقی:
     ```go
     fmt.Println(true && false) // false
     fmt.Println(true || false) // true
     fmt.Println(!true)         // false
     ```

4. **بایت و رون (Byte and Rune)**:
   - `byte`: نام مستعار برای `uint8`، برای ذخیره بایت‌ها.
     ```go
     var b byte = 'A' // 65
     ```
   - `rune`: نام مستعار برای `int32`، برای کاراکترهای یونیکد.
     ```go
     var r rune = '😊' // 128522
     ```

   **توضیح**:
   - `byte` برای داده‌های خام (مثل فایل‌ها) مناسب است.
   - `rune` برای پردازش متن‌های چندزبانه و یونیکد استفاده می‌شود.
   - **مثال**:
     ```go
     s := "سلام"
     runes := []rune(s)
     fmt.Println(len(s), len(runes)) // 6 3 (بایت‌ها vs کاراکترها)
     ```

### 3.2. انواع داده‌های مرکب
**توضیح**: انواع مرکب برای ذخیره داده‌های پیچیده‌تر استفاده می‌شوند.

1. **آرایه (Array)**:
   ```go
   var arr [3]int = [3]int{1, 2, 3}
   ```

   **توضیح**:
   - آرایه‌ها اندازه ثابت دارند و نوع عناصرشان مشخص است.
   - دسترسی:
     ```go
     fmt.Println(arr[0]) // 1
     arr[1] = 20        // تغییر
     ```
   - **نکته**: آرایه‌ها به دلیل اندازه ثابت کمتر استفاده می‌شوند؛ اسلایس‌ها جایگزین رایج‌تر هستند.

2. **اسلایس (Slice)**:
   ```go
   var slice []int = []int{1, 2, 3}
   slice = append(slice, 4) // افزودن
   ```

   **توضیح**:
   - اسلایس‌ها مرجعی به بخشی از آرایه هستند و اندازه پویا دارند.
   - با `make` می‌توان طول و ظرفیت اولیه مشخص کرد:
     ```go
     s := make([]int, 3, 5) // طول 3، ظرفیت 5
     ```
   - عملیات:
     ```go
     s = s[1:3] // برش
     fmt.Println(len(s), cap(s)) // طول و ظرفیت
     ```

3. **مپ (Map)**:
   ```go
   var m map[string]int = map[string]int{
       "Ali": 30,
       "Bob": 25,
   }
   m["Ali"] = 31 // به‌روزرسانی
   delete(m, "Bob") // حذف
   ```

   **توضیح**:
   - مپ‌ها مجموعه‌ای از جفت‌های کلید-مقدار هستند.
   - بررسی وجود کلید:
     ```go
     value, exists := m["Ali"]
     fmt.Println(value, exists) // 31 true
     ```
   - **نکته**: مپ باید با `make` یا مقدار اولیه ساخته شود:
     ```go
     m = make(map[string]int)
     ```

4. **استراکچر (Struct)**:
   ```go
   type Person struct {
       Name string
       Age  int
   }
   var p Person = Person{Name: "Ali", Age: 30}
   p.Age = 31 // تغییر
   ```

   **توضیح**:
   - Struct برای گروه‌بندی داده‌های مرتبط استفاده می‌شود.
   - دسترسی به فیلدها با `.`:
     ```go
     fmt.Println(p.Name) // Ali
     ```
   - Structها برای مدل‌سازی داده‌های پیچیده (مثل مدل‌های دیتابیس) بسیار مفیدند.

5. **اشاره‌گر (Pointer)**:
   ```go
   var x int = 10
   var p *int = &x // اشاره‌گر به x
   *p = 20         // تغییر مقدار x
   fmt.Println(x)  // 20
   ```

   **توضیح**:
   - اشاره‌گرها آدرس حافظه یک متغیر را ذخیره می‌کنند.
   - `&` آدرس را می‌گیرد، `*` مقدار را تغییر می‌دهد.
   - **کاربرد**: برای تغییر مستقیم متغیرها در توابع یا صرفه‌جویی در حافظه.

6. **رابط (Interface)**:
   ```go
   type Speaker interface {
       Speak() string
   }
   type Dog struct{}
   func (d Dog) Speak() string { return "Woof!" }
   var s Speaker = Dog{}
   fmt.Println(s.Speak()) // Woof!
   ```

   **توضیح**:
   - رابط‌ها مجموعه‌ای از متدها را تعریف می‌کنند.
   - هر نوع که این متدها را پیاده‌سازی کند، رابط را ارضا می‌کند.
   - **کاربرد**: برای انعطاف‌پذیری و تست‌پذیری (مثل mocking).

7. **کانال (Channel)**:
   ```go
   ch := make(chan int)
   go func() { ch <- 42 }()
   fmt.Println(<-ch) // 42
   ```

   **توضیح**:
   - کانال‌ها برای ارتباط بین goroutine‌ها استفاده می‌شوند.
   - با `make` ساخته می‌شوند و می‌توانند بافر داشته باشند:
     ```go
     ch := make(chan int, 10) // بافر 10
     ```
   - **کاربرد**: هماهنگی در برنامه‌های همزمان.

### 3.3. مقدار پیش‌فرض (Zero Value)
**توضیح**: Go به متغیرهای بدون مقدار اولیه، مقدار پیش‌فرض اختصاص می‌دهد:
- `int`, `float`: `0`
- `string`: `""`
- `bool`: `false`
- `pointer`, `slice`, `map`, `channel`, `interface`: `nil`

**مثال**:
```go
var s []int
fmt.Println(s == nil) // true
```

**چرا مهم است؟**: این رفتار از خطاهای زمان اجرا (مثل null pointer exception) جلوگیری می‌کند.

### 3.4. نکات پیشرفته در انواع داده‌ها
- **اسلایس و ظرفیت**:
  ```go
  s := make([]int, 2, 5) // طول 2، ظرفیت 5
  s = append(s, 1, 2, 3)
  fmt.Println(len(s), cap(s)) // 5, 5
  ```

  **توضیح**:
  - ظرفیت (capacity) تعداد عناصری است که اسلایس بدون تخصیص حافظه جدید می‌تواند نگه دارد.
  - تنظیم ظرفیت اولیه باعث کاهش تخصیص‌های مکرر حافظه می‌شود.

- **مپ و همزمانی**:
  ```go
  var mu sync.Mutex
  m := make(map[string]int)
  mu.Lock()
  m["key"] = 1
  mu.Unlock()
  ```

  **توضیح**:
  - مپ‌ها thread-safe نیستند و برای دسترسی همزمان نیاز به قفل (mutex) دارند.
  - **جایگزین**: از `sync.Map` برای موارد خاص استفاده کنید.

- **اشاره‌گر و nil**:
  ```go
  var p *int
  if p == nil {
      fmt.Println("Pointer is nil")
  }
  ```

  **توضیح**:
  - بررسی `nil` برای جلوگیری از خطاهای زمان اجرا ضروری است.
  - **کاربرد**: در توابعی که ممکن است مقدار معتبر نداشته باشند.

### 3.5. خطاهای رایج در انواع داده‌ها
- **دسترسی به اسلایس خارج از محدوده**:
  ```go
  s := []int{1, 2}
  fmt.Println(s[2]) // خطا: index out of range
  ```

  **راه‌حل**:
  ```go
  if len(s) > 2 {
      fmt.Println(s[2])
  }
  ```

- **استفاده از مپ بدون مقداردهی اولیه**:
  ```go
  var m map[string]int
  m["key"] = 1 // خطا: assignment to nil map
  ```

  **راه‌حل**:
  ```go
  m = make(map[string]int)
  ```

- **اشتباه در استفاده از اشاره‌گر**:
  ```go
  var p *int
  *p = 10 // خطا: nil pointer dereference
  ```

  **راه‌حل**:
  ```go
  x := 10
  p = &x
  *p = 10
  ```

---

## 4. ثابت‌ها (Constants)

### 4.1. تعریف ثابت
**توضیح**: ثابت‌ها مقادیری هستند که در زمان اجرا تغییر نمی‌کنند و برای مقادیر ثابت مثل تنظیمات یا مقادیر ریاضی استفاده می‌شوند.
```go
const pi float64 = 3.14159
const greeting = "Hello"
```

**توضیح**:
- با `const` تعریف می‌شوند.
- فقط برای انواع پایه (عدد، رشته، بولین) قابل استفاده‌اند.
- **کاربرد**: برای مقادیر غیرقابل تغییر مثل `pi` یا تنظیمات ثابت.

### 4.2. ثابت‌های چندگانه
```go
const (
    Monday    = 1
    Tuesday   = 2
    Wednesday = 3
)
```

**توضیح**:
- بلاک `const` برای تعریف چندین ثابت مرتبط استفاده می‌شود.
- خوانایی کد را افزایش می‌دهد و برای مقادیر مرتبط (مثل روزها) مناسب است.

### 4.3. ثابت‌های iota
**توضیح**: `iota` برای تعریف ثابت‌های متوالی استفاده می‌شود و به طور خودکار مقدار را افزایش می‌دهد.
```go
const (
    Read   = 1 << iota // 1
    Write              // 2
    Execute            // 4
)
```

**توضیح**:
- `iota` از 0 شروع می‌شود و در هر خط افزایش می‌یابد.
- `1 << iota` برای ایجاد مقادیر باینری (مثل مجوزها) استفاده می‌شود.
- **مثال پیشرفته**:
  ```go
  const (
      KB = 1 << (10 * iota) // 1 << 10 = 1024
      MB                    // 1 << 20
      GB                    // 1 << 30
  )
  ```

### 4.4. نکات پیشرفته در ثابت‌ها
- **ثابت‌های بدون نوع (Untyped Constants)**:
  ```go
  const x = 42 // بدون نوع
  var i int = x
  var f float64 = x
  ```

  **توضیح**:
  - ثابت‌های بدون نوع می‌توانند به انواع مختلف تبدیل شوند.
  - این انعطاف‌پذیری برای استفاده در محاسبات عمومی مفید است.

- **استفاده در محاسبات زمان کامپایل**:
  ```go
  const size = 10
  var arr [size]int // اندازه آرایه در زمان کامپایل
  ```

  **توضیح**:
  - ثابت‌ها در زمان کامپایل ارزیابی می‌شوند و برای تعریف اندازه آرایه‌ها مناسب‌اند.

### 4.5. خطاهای رایج
- **تلاش برای تغییر ثابت**:
  ```go
  const x = 10
  x = 20 // خطا: cannot assign to x
  ```

  **راه‌حل**: از متغیر به جای ثابت استفاده کنید.

- **استفاده از `iota` خارج از بلاک `const`**:
  ```go
  var x = iota // خطا
  ```

  **راه‌حل**: `iota` فقط در بلاک `const` معتبر است.

---

## 5. تبدیل نوع (Type Conversion)

**توضیح**: Go از تبدیل صریح نوع پشتیبانی می‌کند و تبدیل ضمنی (مثل برخی زبان‌ها) وجود ندارد.

```go
var i int = 42
var f float64 = float64(i) // تبدیل به float64
var u uint = uint(f)       // تبدیل به uint
```

**توضیح**:
- تبدیل نوع با استفاده از نام نوع (مثل `float64(i)`) انجام می‌شود.
- تبدیل صریح از خطاهای غیرمنتظره جلوگیری می‌کند.

### 5.1. تبدیل رشته به عدد
```go
s := "123"
i, err := strconv.Atoi(s) // تبدیل به int
if err != nil {
    fmt.Println("Conversion error:", err)
}
f, err := strconv.ParseFloat(s, 64) // تبدیل به float64
```

**توضیح**:
- پکیج `strconv` برای تبدیل رشته به عدد استفاده می‌شود.
- `Atoi` برای تبدیل به `int` و `ParseFloat` برای `float64`.
- بررسی `err` ضروری است، چون ورودی نامعتبر (مثل `"abc"`) باعث خطا می‌شود.

### 5.2. تبدیل عدد به رشته
```go
i := 42
s := strconv.Itoa(i) // "42"
s2 := fmt.Sprintf("%d", i) // "42"
```

**توضیح**:
- `Itoa` روش مستقیم برای تبدیل `int` به رشته است.
- `fmt.Sprintf` انعطاف‌پذیرتر است اما کندتر.

### 5.3. نکات پیشرفته
- **تبدیل نوع در struct**:
  ```go
  type UserID int
  var id UserID = 42
  var plainID int = int(id)
  ```

  **توضیح**:
  - برای انواع سفارشی (مثل `UserID`) باید تبدیل صریح انجام شود.
  - این روش برای جداسازی مفهومی انواع مفید است.

- **بررسی ایمنی تبدیل**:
  ```go
  var f float64 = 3.14
  i := int(f) // 3 (بخش اعشاری حذف می‌شود)
  ```

  **توضیح**:
  - تبدیل به نوع کوچک‌تر (مثل `float64` به `int`) ممکن است داده را تغییر دهد.
  - باید تأثیرات را بررسی کنید.

### 5.4. خطاهای رایج
- **تبدیل نوع نامعتبر**:
  ```go
  var s string = "abc"
  i := int(s) // خطا: cannot convert
  ```

  **راه‌حل**: از `strconv` استفاده کنید.

- **نادیده گرفتن خطای تبدیل**:
  ```go
  i, _ := strconv.Atoi("abc") // بد
  ```

  **راه‌حل**:
  ```go
  i, err := strconv.Atoi("abc")
  if err != nil {
      fmt.Println("Error:", err)
  }
  ```

---

## 6. متغیرهای پیشرفته و الگوهای استفاده

### 6.1. Shadowing متغیر
**توضیح**: Shadowing زمانی رخ می‌دهد که متغیری در دامنه داخلی با همان نام متغیر دامنه خارجی تعریف شود.
```go
func main() {
    x := 10
    if true {
        x := 20 // Shadowing
        fmt.Println(x) // 20
    }
    fmt.Println(x) // 10
}
```

**توضیح**:
- متغیر `x` در بلاک `if` متغیر خارجی را "پوشانده" و فقط در آن بلاک معتبر است.
- **هشدار**: Shadowing می‌تواند باعث خطاهای منطقی شود اگر به اشتباه متغیر خارجی را نادیده بگیرید.
- **راه‌حل**: از نام‌های متفاوت یا تخصیص (`=`) استفاده کنید:
  ```go
  x = 20 // به جای x := 20
  ```

### 6.2. متغیرهای موقتی در حلقه‌ها
```go
for i, v := range []int{1, 2, 3} {
    fmt.Println(i, v)
}
```

**توضیح**:
- `i` (اندیس) و `v` (مقدار) فقط در دامنه حلقه معتبرند.
- این رفتار از نشت متغیرها به دامنه خارجی جلوگیری می‌کند.
- **نکته**: برای نادیده گرفتن اندیس یا مقدار از `_` استفاده کنید:
  ```go
  for _, v := range []int{1, 2, 3} {
      fmt.Println(v)
  }
  ```

### 6.3. متغیرهای global و همزمانی
```go
var counter int
var mu sync.Mutex

func increment() {
    mu.Lock()
    counter++
    mu.Unlock()
}
```

**توضیح**:
- متغیرهای global در برنامه‌های همزمان نیاز به قفل (mutex) دارند تا از شرایط رقابتی (race condition) جلوگیری شود.
- `sync.Mutex` دسترسی همزمان را کنترل می‌کند.
- **جایگزین**: از کانال‌ها برای هماهنگی استفاده کنید:
  ```go
  ch := make(chan int)
  go func() { ch <- counter + 1 }()
  counter = <-ch
  ```

### 6.4. استفاده از متغیرهای بدون نام
```go
for _, v := range []int{1, 2, 3} {
    fmt.Println(v) // نادیده گرفتن اندیس
}
```

**توضیح**:
- `_` برای نادیده گرفتن مقادیری که استفاده نمی‌شوند به کار می‌رود.
- این روش کد را تمیزتر می‌کند و از خطاهای متغیرهای استفاده‌نشده جلوگیری می‌کند.

### 6.5. نکات پیشرفته
- **بازیافت متغیرها**:
  ```go
  var err error
  _, err = someFunc()
  if err != nil {
      return err
  }
  _, err = anotherFunc() // استفاده مجدد از err
  ```

  **توضیح**:
  - استفاده مجدد از متغیرها (مثل `err`) تخصیص حافظه را کاهش می‌دهد.
  - این الگو در مدیریت خطاها رایج است.

- **متغیرهای صادراتی در بسته‌ها**:
  ```go
  package mypkg
  var Config = "global config" // صادراتی
  ```

  **توضیح**:
  - متغیرهای صادراتی برای تنظیمات عمومی یا APIهای بسته استفاده می‌شوند.
  - باید با دقت مدیریت شوند تا از تغییرات غیرمنتظره جلوگیری شود.

### 6.6. خطاهای رایج
- **Shadowing غیرعمدی**:
  ```go
  x := 10
  if true {
      x := 20 // ممکن است به اشتباه متغیر خارجی را نادیده بگیرید
  }
  ```

  **راه‌حل**: از ابزارهایی مثل `go vet` برای تشخیص Shadowing استفاده کنید.

- **استفاده از متغیرهای global بدون قفل**:
  ```go
  var counter int
  go func() { counter++ }() // خطا: race condition
  ```

  **راه‌حل**: از `sync.Mutex` یا کانال‌ها استفاده کنید.

---

## 7. بهترین شیوه‌ها در استفاده از متغیرها

**توضیح**: رعایت بهترین شیوه‌ها باعث خوانایی، نگهداری، و عملکرد بهتر کد می‌شود.

1. **نام‌گذاری معنادار**:
   ```go
   userCount := 100 // خوب
   x := 100         // بد
   ```

   **توضیح**:
   - نام‌ها باید هدف متغیر را به‌وضوح نشان دهند.
   - از نام‌های مبهم مثل `x`, `y` جز در حلقه‌ها اجتناب کنید.

2. **حداقل کردن دامنه**:
   ```go
   func calculate() int {
       result := 0 // دامنه محلی
       // محاسبات
       return result
   }
   ```

   **توضیح**:
   - تعریف متغیر در نزدیک‌ترین دامنه ممکن از نشت و سوءاستفاده جلوگیری می‌کند.

3. **استفاده از استنتاج نوع برای خوانایی**:
   ```go
   name := "Ali" // بهتر از var name string = "Ali"
   ```

   **توضیح**:
   - `:=` کد را مختصر و خوانا می‌کند، به‌ویژه در توابع.

4. **اجتناب از متغیرهای global غیرضروری**:
   ```go
   func process(name string) string {
       return "Hello, " + name
   }
   ```

   **توضیح**:
   - به جای متغیر global، از پارامترها و مقادیر بازگشتی استفاده کنید.

5. **بررسی مقادیر nil**:
   ```go
   var s *string
   if s == nil {
       fmt.Println("String pointer is nil")
   }
   ```

   **توضیح**:
   - بررسی `nil` برای اشاره‌گرها، اسلایس‌ها، و مپ‌ها از خطاهای زمان اجرا جلوگیری می‌کند.

6. **استفاده از ثابت‌ها برای مقادیر ثابت**:
   ```go
   const maxRetries = 3
   ```

   **توضیح**:
   - ثابت‌ها برای مقادیر غیرقابل تغییر خوانایی و ایمنی را افزایش می‌دهند.

---

## 8. ابزارها و تکنیک‌های مرتبط

### 8.1. بررسی متغیرهای استفاده‌نشده
```bash
go vet
```

**توضیح**:
- ابزار `go vet` متغیرهای تعریف‌شده اما استفاده‌نشده را شناسایی می‌کند.
- این ابزار کد را تمیز و بدون خطا نگه می‌دارد.

### 8.2. فرمت‌بندی کد
```bash
go fmt
```

**توضیح**:
- `go fmt` کد را به‌صورت استاندارد فرمت‌بندی می‌کند.
- نام‌گذاری و ساختار متغیرها را یکپارچه می‌کند.

### 8.3. پروفایلینگ حافظه
```bash
go tool pprof mem.out
```

**توضیح**:
- برای بررسی تخصیص متغیرها و بهینه‌سازی حافظه استفاده می‌شود.
- به‌ویژه برای اسلایس‌ها و مپ‌های بزرگ مفید است.

### 8.4. مستندسازی متغیرها
```go
// MaxConnections تعداد حداکثر اتصال‌های همزمان
const MaxConnections = 100
```

**توضیح**:
- افزودن کامنت‌های دقیق برای متغیرها و ثابت‌ها درک کد را آسان‌تر می‌کند.
- ابزار `godoc` این کامنت‌ها را به مستندات تبدیل می‌کند.

---

## 9. خطاهای رایج و راه‌حل‌ها

**توضیح**: شناسایی و رفع خطاهای رایج در استفاده از متغیرها برای توسعه کد باکیفیت ضروری است.

1. **عدم بررسی خطا در تبدیل نوع**:
   ```go
   // بد
   i, _ := strconv.Atoi("abc")
   // خوب
   i, err := strconv.Atoi("abc")
   if err != nil {
       fmt.Println("Error:", err)
   }
   ```

   **توضیح**:
   - نادیده گرفتن خطاها می‌تواند باعث رفتار غیرمنتظره شود.
   - همیشه خطاها را بررسی کنید.

2. **استفاده از اشاره‌گر بدون مقداردهی اولیه**:
   ```go
   // بد
   var p *int
   *p = 10 // خطا: nil pointer dereference
   // خوب
   x := 10
   p = &x
   *p = 20
   ```

   **توضیح**:
   - اشاره‌گرهای `nil` باعث خطاهای زمان اجرا می‌شوند.
   - قبل از استفاده، اشاره‌گر را مقداردهی کنید.

3. **تخصیص بیش از حد متغیرهای موقتی**:
   ```go
   // بد
   temp1 := calculateSomething()
   temp2 := process(temp1)
   return temp2
   // خوب
   return process(calculateSomething())
   ```

   **توضیح**:
   - متغیرهای موقتی غیرضروری حافظه و خوانایی را تحت تأثیر قرار می‌دهند.
   - مستقیماً از نتایج توابع استفاده کنید.

4. **Shadowing غیرعمدی**:
   ```go
   // بد
   x := 10
   if true {
       x := 20 // Shadowing
   }
   // خوب
   x := 10
   if true {
       x = 20
   }
   ```

   **توضیح**:
   - Shadowing می‌تواند باعث اشتباه در دسترسی به متغیر خارجی شود.
   - از ابزارهای تحلیل کد استفاده کنید.

---

## 10. نکات پیشرفته و الگوهای کاربردی

### 10.1. استفاده از متغیرها در همزمانی
```go
func main() {
    var wg sync.WaitGroup
    counter := 0
    mu := sync.Mutex{}
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    wg.Wait()
    fmt.Println(counter) // 10
}
```

**توضیح**:
- متغیر `counter` به‌صورت همزمان توسط چندین goroutine تغییر می‌کند.
- `sync.Mutex` از شرایط رقابتی جلوگیری می‌کند.
- `sync.WaitGroup` برای انتظار اتمام goroutine‌ها استفاده می‌شود.
- **کاربرد**: در سیستم‌های چندنخی مثل سرورها.

### 10.2. متغیرهای پویا در حلقه‌ها
```go
for i := 0; i < 5; i++ {
    i := i // کپی متغیر
    go func() {
        fmt.Println(i)
    }()
}
```

**توضیح**:
- بدون کپی `i`، همه goroutine‌ها به مقدار نهایی `i` دسترسی پیدا می‌کنند.
- کپی متغیر تضمین می‌کند که هر goroutine مقدار درست را ببیند.
- **کاربرد**: در حلقه‌هایی که goroutine ایجاد می‌کنند.

### 10.3. متغیرهای قابل تنظیم در زمان اجرا
```go
var debugMode bool

func init() {
    debugMode = os.Getenv("DEBUG") == "true"
}

func logDebug(msg string) {
    if debugMode {
        fmt.Println("Debug:", msg)
    }
}
```

**توضیح**:
- متغیر `debugMode` بر اساس متغیر محیطی تنظیم می‌شود.
- تابع `init` قبل از `main` اجرا می‌شود و برای تنظیمات اولیه مناسب است.
- **کاربرد**: برای ویژگی‌های قابل تنظیم مثل لاگ‌گیری.

### 10.4. استفاده از متغیرهای exported در API
```go
package mypkg

type Config struct {
    MaxRetries int
}

var DefaultConfig = Config{MaxRetries: 3}
```

**توضیح**:
- متغیر `DefaultConfig` در بسته‌های دیگر قابل دسترسی است.
- برای ارائه تنظیمات پیش‌فرض در APIهای بسته مناسب است.
- **نکته**: از تغییرات ناخواسته با کپی یا قفل جلوگیری کنید.

---

## 11. منابع یادگیری و انجمن

### 11.1. منابع یادگیری
**توضیح**: منابع زیر برای یادگیری عمیق‌تر Go توصیه می‌شوند:
- **مستندات رسمی**:
  - `https://golang.org/doc/`: شامل آموزش‌ها و مرجع کامل.
  - `https://go.dev/tour`: آموزش تعاملی برای مبتدیان.
- **کتاب‌ها**:
  - "The Go Programming Language" (Donovan & Kernighan): مرجع جامع.
- **دوره‌های آنلاین**:
  - Go by Example (`https://gobyexample.com`): مثال‌های عملی.
  - Udemy: "Learn Go Programming".
- **انجمن‌ها**:
  - Reddit: `r/golang` برای بحث و پرس‌وجو.
  - Gophers Slack: `https://gophers.slack.com` برای ارتباط با جامعه.
  - Stack Overflow: تگ `go` برای سوالات فنی.

### 11.2. مشارکت در پروژه‌ها
**توضیح**:
- مطالعه کد پروژه‌های متن‌باز مثل `kubernetes` یا `hugo` برای یادگیری الگوهای واقعی.
- مشارکت در رفع باگ‌های ساده یا بهبود مستندات در مخازن GitHub.

### 11.3. نکات پیشرفته
- **مطالعه کد استاندارد Go**: کدهای پکیج‌های استاندارد (مثل `fmt`, `net/http`) در پوشه `src` Go.
- **نوشتن وبلاگ**: تجربیات یادگیری خود را به اشتراک بگذارید تا درک عمیق‌تری پیدا کنید.

### 11.4. خطاهای رایج
- **نادیده گرفتن مستندات رسمی**: مستندات Go بهترین منبع برای یادگیری دقیق هستند.
- **کپی‌برداری بدون درک**: کپی کد بدون فهم باعث خطاهای منطقی می‌شود.

---

## 12. نتیجه‌گیری

**توضیح**: این جزوه مفاهیم پایه و اولیه زبان Go با تمرکز بر متغیرها و موارد مرتبط را به‌صورت جامع و عمیق پوشش داد. از تعریف متغیرها، انواع داده‌ها، ثابت‌ها، و تبدیل نوع تا دامنه‌ها، الگوهای پیشرفته، و بهترین شیوه‌ها، هر بخش با توضیحات کامل، مثال‌های عملی، و نکات تخصصی ارائه شد. برای یادگیری عمیق‌تر:
- مطالعه مستندات رسمی: `https://golang.org/doc/`
- تمرین با پروژه‌های ساده مثل ساخت CLI یا API.
- مشارکت در پروژه‌های متن‌باز برای تجربه واقعی.